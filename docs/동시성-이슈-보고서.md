# 동시성 이슈 보고서
## 목차

1. [문제상황](#1-문제상황)
2. [해결전략](#2-해결전략)
3. [테스트결과](#3-테스트결과)

---

## 1. 문제상황

### 1.1 개요

시스템 내 동시성 처리가 필요한 영역에서 동시성 이슈가 발생할수있는 부분이 아래와 같이 존재

| 영역             | 문제 유형       | 현재 상태     |
|----------------|-------------|-----------|
| 잔액 충전          | Lost Update | ✅ 해결됨     |
| 잔액 차감          | Race Condition | ✅ 해결됨     |
| 재고 감소 (1개 상품)  | Overselling | ✅ 해결됨     |
| 재고 감소 (대량 주문)  | Overselling | ✅ 해결됨     |
| 쿠폰 발급 (선착순 수량) | 초과 발급       | ✅ 해결됨     |
| 쿠폰 발급 (1인당 1개) | 중복 발급       | ✅ 해결됨     |
| 쿠폰 사용 (주문)     | 중복 사용       | ✅ 해결됨     |

### 1.2 현재 적용된 동시성 제어

아래와 같은 방법으로 동시성 이슈를 보호

| 영역         | 보호 메커니즘                                 | 비고         |
|------------|-----------------------------------------|------------|
| 잔액 충전      | 조건부 UPDATE                              | 원자적 처리     |
| 잔액 차감      | 조건부 UPDATE                              | 원자적 처리     |
| 재고 감소      | 조건부 UPDATE                              | 원자적 처리     |
| 쿠폰 발급 (수량) | 조건부 UPDATE                              | 수량 초과 방지   |
| 쿠폰 발급 (중복) | DB Unique 제약 (`uk_coupon_member_summary`) | 중복 발급 방지   |
| 쿠폰 사용      | 조건부 UPDATE                              | 중복 사용 방지   |

---

### 1.3 상세 문제 분석

#### 1.3.1 잔액 충전 동시성 이슈

**문제 코드 위치**: `MemberBalanceService.recharge()`

**시나리오**
```
초기 상태: 사용자 A의 잔액 10,000원

[동시 요청]
- 요청 1: 5,000원 충전
- 요청 2: 3,000원 충전

기대 결과: 최종 잔액 18,000원 (10,000 + 5,000 + 3,000)
실제 결과: 13,000원 또는 15,000원 (한 충전 금액 유실)
```

**발생 원인**
```
시간 →
Thread 1: READ(10,000) ───────────────────── WRITE(15,000)
Thread 2: ────── READ(10,000) ── WRITE(13,000)

결과: Thread 1의 충전(5,000원)이 Thread 2에 의해 덮어씀 (Lost Update)
```

**비즈니스 영향**
- 고객이 충전한 금액이 유실됨
- 금전적 손실 발생
- 고객 신뢰도 하락

---

#### 1.3.2 재고 감소 동시성 이슈

**문제 코드 위치**: `ProductSummaryService.reduceStock()`

**시나리오 (1개 상품)**
```
초기 상태: 상품 재고 1개

[동시 요청 - 다른 사용자]
- 사용자 A: 1개 주문
- 사용자 B: 1개 주문

기대 결과: 1명 성공, 1명 실패 (재고 부족)
실제 결과: 2명 모두 성공 (Overselling)
```

**발생 원인**
```
시간 →
Thread 1 (User A): LOCK(member_A) ── 재고확인(1) ── 차감 ── COMMIT
Thread 2 (User B): LOCK(member_B) ── 재고확인(1) ── 차감 ── COMMIT

문제: Member Lock은 사용자별로 분리되어 있어,
      다른 사용자 간의 동시 재고 접근을 보호하지 못함
```

**비즈니스 영향**
- 재고보다 많은 주문 접수
- 배송 불가 상황 발생
- 주문 취소 처리 필요
- 고객 불만 및 신뢰도 하락

---

#### 1.3.3 쿠폰 발급 동시성 이슈 (1인당 1개 발급)

**문제 코드 위치**: `CouponIssuanceFacade.issue()` 내 정책 검증

**시나리오**
```
초기 상태: 1인당 1개 발급 정책 쿠폰, 사용자 C에게 미발급

[동시 요청 - 동일 사용자]
- 요청 1: 쿠폰 발급 (idempotency-key-1)
- 요청 2: 쿠폰 발급 (idempotency-key-2)

기대 결과: 1건 성공, 1건 실패 (이미 발급됨)
실제 결과: 2건 모두 성공 (중복 발급)
```

**발생 원인**
```
시간 →
요청1: SELECT 쿠폰(0개) ── 정책검증(✓) ── INSERT ──
요청2: ── SELECT 쿠폰(0개) ── 정책검증(✓) ── INSERT

문제: CouponIssuance Lock은 수량만 보호,
      1인당 1개 발급 정책의 기발급 여부 체크는 Lock 없이 수행됨
```

**비즈니스 영향**
- 회원당 1회 발급 정책 위반
- 마케팅 예산 초과
- 공정성 이슈

---

## 2. 해결전략

### 2.1 잔액 충전/차감 동시성 제어

**선택 전략**: 조건부 UPDATE

**선택 근거**:
- 원자적 처리: `UPDATE ... SET balance = balance + :amount` 또는 `UPDATE ... WHERE balance >= :amount` 로 조회-검증-수정을 단일 쿼리로 처리
- Lock 없음: SELECT FOR UPDATE 대비 성능 우수
- 단순한 구조: 추가 컬럼이나 복잡한 예외 처리 로직 불필요

**구현 방안**:
1. `MemberBalanceJpaRepository`에 조건부 UPDATE 쿼리 추가
   - `rechargeBalance()`: `SET balance = balance + :amount WHERE id = :id`
   - `reduceBalanceByMemberId()`: `SET balance = balance - :amount WHERE member.id = :memberId AND balance >= :amount`
2. `MyBalanceOutput`에 `atomicRecharge()`, `atomicReduceByMemberId()` 메서드 추가
3. `MyBalanceInteractor`에서 조건부 UPDATE 사용
4. 영향받은 행이 0이면 잔액 부족 또는 잔고 없음으로 처리

---

### 2.2 재고 감소 동시성 제어

**선택 전략**: 조건부 UPDATE

**선택 근거**:
- 재고 충분 시 불필요한 재시도 방지: 낙관적 락은 version 충돌 시 재고가 충분해도 재시도 필요
- 원자적 처리: `UPDATE ... WHERE stock_quantity >= :quantity` 로 조회-검증-수정을 단일 쿼리로 처리
- 단순한 구조: 추가 컬럼이나 예외 처리 로직 불필요

**구현 방안**:
1. Repository에 조건부 UPDATE 쿼리 추가
2. 영향받은 행이 0이면 재고 부족으로 처리

---

### 2.3 쿠폰 발급 동시성 제어

**선택 전략**: 조건부 UPDATE + DB Unique 제약

**선택 근거**:
- 선착순 수량 제한: 조건부 UPDATE로 `issuedCount < maxCount` 조건 체크
-  중복 발급: DB Unique 제약으로 `member_id + coupon_summary_id` 조합 중복 방지
- 쿠폰 사용 중복 방지: 조건부 UPDATE로 `usingAt IS NULL` 조건 체크

**구현 방안**:
1. `CouponIssuanceJpaRepository.atomicIssue()`: 조건부 UPDATE 쿼리
   - `SET issuedCount = issuedCount + 1 WHERE issuedCount < maxCount AND startAt <= now AND endAt >= now`
2. `CouponJpaEntity`에 Unique 제약 추가
   - `@UniqueConstraint(name = "uk_coupon_member_summary", columnNames = ["member_id", "coupon_summary_id"])`
3. `CouponPersistenceAdapter.save()`에서 `DataIntegrityViolationException` 발생 시 `ConflictResourceException` throw
4. `CouponJpaRepository.atomicUse()`: 조건부 UPDATE 쿼리
   - `SET usingAt = :now WHERE memberId = :memberId AND couponSummaryId = :couponSummaryId AND usingAt IS NULL`

---

## 3. 테스트결과

### 3.1 테스트 실행 요약

| 테스트                    | 결과 | 동시성 이슈 |
|------------------------|------|-------------|
| 잔액 충전 동시성 제어           | ✅ 통과 | 없음 (조건부 UPDATE) |
| 잔액 차감 동시성 제어 (주문)      | ✅ 통과 | 없음 (조건부 UPDATE) |
| 재고 감소 동시성 제어 (1개 상품)   | ✅ 통과 | 없음 (조건부 UPDATE) |
| 재고 감소 동시성 제어 (대량 주문)   | ✅ 통과 | 없음 (조건부 UPDATE) |
| 쿠폰 발급 동시성 제어 (수량 제한)   | ✅ 통과 | 없음 (조건부 UPDATE) |
| 쿠폰 발급 동시성 제어 (중복발급 제한) | ✅ 통과 | 없음 (DB Unique 제약) |
| 쿠폰 사용 동시성 제어 (주문)      | ✅ 통과 | 없음 (조건부 UPDATE) |

### 3.2 테스트별 상세 결과

#### 잔액 충전 동시성 제어

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 18,000원 (10,000 + 5,000 + 3,000)
- 실제: 18,000원
- 해결 방법: atomicRecharge() - SET balance = balance + :amount
```

#### 잔액 차감 동시성 제어

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 1명 성공, 1명 실패 (잔액 부족)
- 실제: 1명 성공, 1명 실패
- 해결 방법: atomicReduceByMemberId() - WHERE balance >= :amount
```

#### 재고 감소 동시성 제어 (1개 상품)

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 1명 성공, 1명 실패
- 실제: 1명 성공, 1명 실패 (재고 부족)
```

#### 재고 감소 동시성 제어 (대량 주문)

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 최대 2명 성공 (4개 판매)
- 실제: 재고 한도 내에서만 주문 성공
```

#### 쿠폰 발급 동시성 제어 (수량 제한)

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 1명 성공, 1명 실패 (maxCount 초과)
- 실제: 1명 성공, 1명 실패
- 해결 방법: atomicIssue() - SET issuedCount = issuedCount + 1 WHERE issuedCount < maxCount
```

#### 쿠폰 발급 동시성 제어 (중복발급 제한)

```
✅ 통과 (DB Unique 제약 적용)
- 기대: 1건 성공, 1건 실패
- 실제: 1건 성공, 1건 실패 (이미 발급된 쿠폰)
- 해결 방법: DB Unique 제약 (uk_coupon_member_summary) + DataIntegrityViolationException 예외 처리
```

#### 쿠폰 사용 동시성 제어 (주문)

```
✅ 통과 (조건부 UPDATE 적용)
- 기대: 1건 성공, 1건 실패 (이미 사용된 쿠폰)
- 실제: 1건 성공, 1건 실패
- 해결 방법: atomicUse() - SET usingAt = :now WHERE usingAt IS NULL
```

---

### 3.3 테스트 파일 위치

```
src/test/kotlin/kr/hhplus/be/server/application/concurrency/
├── BalanceConcurrencyIntegrationTest.kt   # 잔액 충전/차감 동시성 테스트
├── StockConcurrencyIntegrationTest.kt     # 재고 감소 동시성 테스트
└── CouponConcurrencyIntegrationTest.kt    # 쿠폰 발급/사용 동시성 테스트

src/test/resources/sql/
├── balance-concurrency-setup.sql
├── balance-concurrency-cleanup.sql
├── stock-concurrency-setup.sql
├── stock-concurrency-cleanup.sql
├── coupon-concurrency-setup.sql
└── coupon-concurrency-cleanup.sql
```

### 3.4 테스트 실행 명령어

```bash
# 전체 동시성 테스트 실행
./gradlew test --tests "*ConcurrencyIntegrationTest"

# 개별 테스트 실행
./gradlew test --tests "BalanceConcurrencyIntegrationTest"
./gradlew test --tests "StockConcurrencyIntegrationTest"
./gradlew test --tests "CouponConcurrencyIntegrationTest"
```