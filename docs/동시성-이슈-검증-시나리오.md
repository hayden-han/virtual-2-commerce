# 동시성 이슈 검증 시나리오

## 목차
1. [개요](#개요)
2. [잔액 동시성 테스트](#잔액-동시성-테스트)
3. [재고 동시성 테스트](#재고-동시성-테스트)
4. [쿠폰 동시성 테스트](#쿠폰-동시성-테스트)
5. [테스트 실행 방법](#테스트-실행-방법)

---

## 개요

### 목적

이 문서는 `동시성-이슈-분석.md`에서 식별된 동시성 이슈들을 실제로 검증하기 위한 테스트 시나리오를 정의합니다.

### 검증 대상

| 기능 | 예상 문제 | 현재 Lock 적용 여부 | 비고 |
|------|----------|-------------------|------|
| 잔액 충전 | Lost Update | ❌ 없음 | |
| 잔액 차감 | 잔액 부족 검증 우회 | ⚠️ 임시 (Member Lock) | 주문 시 간접 보호 |
| 재고 차감 | Overselling | ❌ 없음 | |
| 쿠폰 발급 | 수량 초과 발급 | ⚠️ 임시 (CouponIssuance Lock) | 분산 환경 미지원 |
| 쿠폰 사용 | 중복 사용 | ⚠️ 임시 (Member Lock) | 주문 시 간접 보호 |

> ⚠️ **임시 Lock 설명**: 현재 적용된 DB Pessimistic Lock은 임시 구현입니다.
> 분산 환경 지원을 위해 추후 Redis 분산 락으로 전환될 예정이며,
> 동시성 테스트에서는 임시 Lock을 제거하고 이슈를 검증합니다.

### 테스트 방법

- **Kotlin Coroutines**: `runBlocking`, `async`, `CompletableDeferred`를 사용하여 동시 요청 시뮬레이션
- **CompletableDeferred**: 모든 코루틴이 준비된 후 동시에 시작하도록 동기화
- **Dispatchers.IO**: 각 요청을 별도 스레드에서 실행

---

## 잔액 동시성 테스트

### TC-BAL-001: 동시 잔액 충전 시 Lost Update 검증

#### 시나리오

같은 사용자가 동시에 2번의 잔액 충전 요청을 보내면, 모든 충전 금액이 정상적으로 반영되어야 합니다.

#### 사전 조건

- 회원 ID: 3001
- 초기 잔액: 10,000원
- 잔액 ID: 3001

#### 테스트 데이터

| 요청 | 충전 금액 |
|------|----------|
| 요청 1 | 5,000원 |
| 요청 2 | 3,000원 |

#### 예상 결과 (정상 동작 시)

- 최종 잔액: 18,000원 (10,000 + 5,000 + 3,000)
- 모든 충전 요청 성공 (HTTP 200)

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (5,000원 충전)     | 요청2 (3,000원 충전)
-----|--------------------------|---------------------------
T1   | SELECT balance (10,000)  |
T2   |                          | SELECT balance (10,000)
T3   | 계산: 10,000 + 5,000     |
T4   |                          | 계산: 10,000 + 3,000
T5   | UPDATE balance = 15,000  |
T6   |                          | UPDATE balance = 13,000  ← 덮어씀!
```

- 최종 잔액: 13,000원 또는 15,000원 (둘 중 하나의 충전 손실)
- **Lost Update 발생**

#### 검증 포인트

1. 두 요청 모두 HTTP 200 응답
2. 최종 잔액이 18,000원이 아니면 동시성 이슈 존재

---

### TC-BAL-002: 동시 잔액 차감 시 잔액 부족 검증 우회

#### 시나리오

잔액이 10,000원인 사용자가 동시에 7,000원씩 2번 차감 요청을 보내면, 하나만 성공해야 합니다.

#### 사전 조건

- 회원 ID: 3002
- 초기 잔액: 10,000원

#### 테스트 데이터

| 요청 | 차감 금액 |
|------|----------|
| 요청 1 | 7,000원 |
| 요청 2 | 7,000원 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (잔액 부족)
- 최종 잔액: 3,000원

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (7,000원 차감)     | 요청2 (7,000원 차감)
-----|--------------------------|---------------------------
T1   | SELECT balance (10,000)  |
T2   |                          | SELECT balance (10,000)
T3   | 검증: 10,000 >= 7,000 ✓  |
T4   |                          | 검증: 10,000 >= 7,000 ✓
T5   | UPDATE balance = 3,000   |
T6   |                          | UPDATE balance = 3,000  ← 음수 방지 실패!
```

- 두 요청 모두 성공
- 최종 잔액: 3,000원 (정상) 또는 -4,000원 (음수, 심각한 버그)
- **Race Condition 발생**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "잔고의 금액이 부족합니다")
3. 최종 잔액이 3,000원

---

## 재고 동시성 테스트

### TC-STK-001: 동시 재고 차감 시 Overselling 검증

#### 시나리오

재고가 1개인 상품을 2명의 사용자가 동시에 주문하면, 1명만 성공해야 합니다.

#### 사전 조건

- 상품 ID: 5001
- 초기 재고: 1개
- 사용자 A ID: 4001, 잔액: 100,000원
- 사용자 B ID: 4002, 잔액: 100,000원

#### 테스트 데이터

| 요청 | 사용자 | 주문 수량 | 상품 가격 |
|------|--------|----------|----------|
| 요청 1 | 4001 | 1개 | 10,000원 |
| 요청 2 | 4002 | 1개 | 10,000원 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (재고 부족)
- 최종 재고: 0개

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 사용자 A 주문            | 사용자 B 주문
-----|--------------------------|---------------------------
T1   | Lock(회원 A) 획득        | Lock(회원 B) 획득  ← 다른 row!
T2   | SELECT stock (1개)       | SELECT stock (1개)
T3   | 검증: 1 >= 1 ✓           | 검증: 1 >= 1 ✓
T4   | UPDATE stock = 0         |
T5   |                          | UPDATE stock = -1  ← Overselling!
```

- 두 요청 모두 성공
- 최종 재고: 0개 또는 -1개
- **Overselling 발생**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "재고가 부족합니다")
3. 최종 재고가 0개
4. 주문은 1건만 생성

---

### TC-STK-002: 동시 대량 주문 시 재고 초과 검증

#### 시나리오

재고가 5개인 상품을 5명의 사용자가 동시에 2개씩 주문하면, 최대 2명만 성공해야 합니다.

#### 사전 조건

- 상품 ID: 5002
- 초기 재고: 5개
- 사용자 ID: 4003 ~ 4007, 각각 잔액 100,000원

#### 테스트 데이터

| 요청 | 사용자 | 주문 수량 |
|------|--------|----------|
| 요청 1 | 4003 | 2개 |
| 요청 2 | 4004 | 2개 |
| 요청 3 | 4005 | 2개 |
| 요청 4 | 4006 | 2개 |
| 요청 5 | 4007 | 2개 |

#### 예상 결과 (정상 동작 시)

- 최대 2개 요청 성공 (4개 = 2 × 2), 나머지 실패
- 최종 재고: 1개 (5 - 4 = 1) 또는 0개 이상

#### 예상 결과 (동시성 이슈 발생 시)

- 3개 이상 요청 성공
- 최종 재고: 음수 (-1, -3, -5 등)
- **심각한 Overselling 발생**

#### 검증 포인트

1. 성공한 주문 수 × 주문 수량 ≤ 초기 재고 (5개)
2. 최종 재고 ≥ 0
3. 총 판매 수량이 초기 재고를 초과하지 않음

---

## 쿠폰 동시성 테스트

> ⚠️ **테스트 목적**: 현재 적용된 임시 Lock(Pessimistic Lock)을 제거했을 때 발생하는 동시성 이슈를 검증합니다.
> 테스트 시에는 Lock이 없는 조회 메서드를 사용하거나, Lock을 우회하는 시나리오를 구성합니다.

### TC-CPN-001: 선착순 쿠폰 수량 초과 발급 검증

#### 시나리오

선착순 쿠폰(maxCount=1)을 2명의 사용자가 동시에 발급 요청하면, 1명만 성공해야 합니다.

#### 사전 조건

- 쿠폰 요약 ID: 6001
- 쿠폰 발급 정보: maxCount=1, issuedCount=0
- 사용자 A ID: 6001
- 사용자 B ID: 6002

#### 테스트 데이터

| 요청 | 사용자 | 쿠폰 |
|------|--------|------|
| 요청 1 | 6001 | 6001 |
| 요청 2 | 6002 | 6001 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (수량 부족)
- 발급된 쿠폰 수: 1개
- issuedCount: 1

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (회원A)            | 요청2 (회원B)
-----|--------------------------|---------------------------
T1   | SELECT issuedCount (0)   |
T2   |                          | SELECT issuedCount (0)
T3   | 검증: 0 < 1 ✓            |
T4   |                          | 검증: 0 < 1 ✓
T5   | INSERT coupon, issuedCount = 1 |
T6   |                          | INSERT coupon, issuedCount = 2  ← 초과 발급!
```

- 두 요청 모두 성공
- 발급된 쿠폰 수: 2개 (maxCount 초과)
- **수량 초과 발급 발생**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "쿠폰발급수량이 부족합니다")
3. 발급된 쿠폰 수가 1개
4. issuedCount가 1

---

### TC-CPN-002: 동일 회원 쿠폰 중복 발급 검증 (OnePerMember 정책)

#### 시나리오

OnePerMember 정책이 적용된 쿠폰을 같은 회원이 동시에 2번 발급 요청하면, 1번만 성공해야 합니다.

#### 사전 조건

- 쿠폰 요약 ID: 6002
- 쿠폰 발급 정보: maxCount=100, issuedCount=0, OnePerMember 정책 적용
- 사용자 C ID: 6003

#### 테스트 데이터

| 요청 | 사용자 | 쿠폰 | Idempotency Key |
|------|--------|------|-----------------|
| 요청 1 | 6003 | 6002 | coupon-req-1 |
| 요청 2 | 6003 | 6002 | coupon-req-2 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (중복 발급 제한)
- 해당 회원의 쿠폰 수: 1개

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (회원C, key-1)     | 요청2 (회원C, key-2)
-----|--------------------------|---------------------------
T1   | SELECT coupons by member (0개) |
T2   |                          | SELECT coupons by member (0개)
T3   | 정책 검증: 기존 쿠폰 없음 ✓ |
T4   |                          | 정책 검증: 기존 쿠폰 없음 ✓
T5   | INSERT coupon            |
T6   |                          | INSERT coupon  ← 중복 발급!
```

- 두 요청 모두 성공
- 해당 회원의 쿠폰 수: 2개
- **OnePerMember 정책 위반**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "중복발급이 제한된 쿠폰입니다")
3. 해당 회원의 쿠폰 수가 1개

---

### TC-CPN-003: 동일 쿠폰 동시 사용 검증 (주문 시)

#### 시나리오

같은 회원이 동일한 쿠폰으로 동시에 2건의 주문을 하면, 1건만 쿠폰이 적용되어야 합니다.

> ⚠️ **검증 대상**: `MyCouponUseCase.using()` 메서드의 동시성 처리
> - 현재는 Member Lock으로 간접 보호되어 있으나, Lock 없이도 `usingAt` 체크가 정확히 동작해야 함
> - 잔액 차감(TC-BAL-002)과 유사하게 주문 흐름에서 쿠폰 사용의 동시성을 별도 검증

#### 사전 조건

- 회원 ID: 5004
- 초기 잔액: 100,000원
- 보유 쿠폰 ID: 6003 (10% 할인, 미사용 상태)
- 상품 ID: 6001 (가격: 10,000원, 재고: 100개)

#### 테스트 데이터

| 요청 | 사용자 | 쿠폰 | 상품 | Idempotency Key |
|------|--------|------|------|-----------------|
| 요청 1 | 5004 | 6001 (couponSummaryId) | 6001 | coupon-use-order-1 |
| 요청 2 | 5004 | 6001 (couponSummaryId) | 6001 | coupon-use-order-2 |

#### 예상 결과 (정상 동작 시)

- 1개 주문 성공 (쿠폰 적용)
- 1개 주문 실패 (이미 사용된 쿠폰)
- 쿠폰의 usingAt: NOT NULL (사용됨)
- 생성된 주문: 1건

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (주문A)            | 요청2 (주문B)
-----|--------------------------|---------------------------
T1   | SELECT coupon (usingAt=null) |
T2   |                          | SELECT coupon (usingAt=null)
T3   | 검증: usingAt == null ✓  |
T4   |                          | 검증: usingAt == null ✓
T5   | UPDATE usingAt = now     |
T6   |                          | UPDATE usingAt = now  ← 중복 사용!
T7   | 주문 생성 (쿠폰 적용)    | 주문 생성 (쿠폰 적용)
```

- 두 요청 모두 성공
- 두 주문 모두 쿠폰 할인 적용
- **동일 쿠폰 이중 사용 발생** (할인 금액 손실)

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "이미 사용된 쿠폰입니다")
3. 쿠폰의 usingAt이 NOT NULL
4. 생성된 주문은 1건
5. 쿠폰 할인이 1번만 적용됨

---

## 테스트 실행 방법

### 테스트 파일 위치

```
src/test/kotlin/kr/hhplus/be/server/
├── application/
│   └── concurrency/
│       ├── BalanceConcurrencyIntegrationTest.kt
│       ├── StockConcurrencyIntegrationTest.kt
│       └── CouponConcurrencyIntegrationTest.kt
└── resources/sql/
    ├── balance-concurrency-setup.sql
    ├── balance-concurrency-cleanup.sql
    ├── stock-concurrency-setup.sql
    ├── stock-concurrency-cleanup.sql
    ├── coupon-concurrency-setup.sql
    └── coupon-concurrency-cleanup.sql
```

### 실행 명령어

```bash
# 전체 동시성 테스트 실행
./gradlew test --tests "*ConcurrencyIntegrationTest"

# 잔액 동시성 테스트만 실행
./gradlew test --tests "BalanceConcurrencyIntegrationTest"

# 재고 동시성 테스트만 실행
./gradlew test --tests "StockConcurrencyIntegrationTest"
```

### 테스트 결과 해석

#### 동시성 이슈가 있는 경우 (현재 상태)

```
✗ TC-BAL-001: 최종 잔액이 18,000원이 아님 (Lost Update)
✗ TC-BAL-002: 두 요청 모두 성공 (Race Condition)
✗ TC-STK-001: 두 요청 모두 성공 (Overselling)
✗ TC-STK-002: 3개 이상 요청 성공 (Overselling)
```

#### 동시성 이슈 해결 후

```
✓ TC-BAL-001: 최종 잔액 18,000원
✓ TC-BAL-002: 1개 성공, 1개 실패 (잔액 부족)
✓ TC-STK-001: 1개 성공, 1개 실패 (재고 부족)
✓ TC-STK-002: 최대 2개 성공, 재고 ≥ 0
```

---

## 테스트 코드 구조

### 공통 패턴

```kotlin
@IntegrationTest
@AutoConfigureMockMvc
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@SqlGroup(
    Sql(scripts = ["/sql/{test}-setup.sql"], executionPhase = BEFORE_TEST_METHOD),
    Sql(scripts = ["/sql/{test}-cleanup.sql"], executionPhase = AFTER_TEST_METHOD),
)
class {Feature}ConcurrencyIntegrationTest {

    @Test
    fun `동시 요청 시 동시성 이슈 검증`() {
        runBlocking {
            val startSignal = CompletableDeferred<Unit>()

            val jobs = requests.map { request ->
                async(Dispatchers.IO) {
                    startSignal.await()  // 모든 코루틴이 준비될 때까지 대기
                    // 요청 실행
                }
            }

            startSignal.complete(Unit)  // 동시 시작
            val responses = jobs.awaitAll()

            // 검증
        }
    }
}
```

---

## 참고 자료

- [동시성 이슈 분석](동시성-이슈-분석.md)
- [아키텍처 및 구조](아키텍처-및-구조.md)
- 기존 동시성 테스트:
  - `CouponIssuanceConcurrencyIntegrationTest.kt`
  - `PlaceOrderConcurrencyIntegrationTest.kt`
