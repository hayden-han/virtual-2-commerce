# 동시성 이슈 검증 시나리오

## 목차
1. [개요](#개요)
2. [잔액 동시성 테스트](#잔액-동시성-테스트)
3. [재고 동시성 테스트](#재고-동시성-테스트)
4. [테스트 실행 방법](#테스트-실행-방법)

---

## 개요

### 목적

이 문서는 `동시성-이슈-분석.md`에서 식별된 동시성 이슈들을 실제로 검증하기 위한 테스트 시나리오를 정의합니다.

### 검증 대상

| 기능 | 예상 문제 | 현재 Lock 적용 여부 |
|------|----------|-------------------|
| 잔액 충전 | Lost Update | ❌ 없음 |
| 잔액 차감 | 잔액 부족 검증 우회 | ❌ 없음 |
| 재고 차감 | Overselling | ❌ 없음 |

### 테스트 방법

- **Kotlin Coroutines**: `runBlocking`, `async`, `CompletableDeferred`를 사용하여 동시 요청 시뮬레이션
- **CompletableDeferred**: 모든 코루틴이 준비된 후 동시에 시작하도록 동기화
- **Dispatchers.IO**: 각 요청을 별도 스레드에서 실행

---

## 잔액 동시성 테스트

### TC-BAL-001: 동시 잔액 충전 시 Lost Update 검증

#### 시나리오

같은 사용자가 동시에 2번의 잔액 충전 요청을 보내면, 모든 충전 금액이 정상적으로 반영되어야 합니다.

#### 사전 조건

- 회원 ID: 3001
- 초기 잔액: 10,000원
- 잔액 ID: 3001

#### 테스트 데이터

| 요청 | 충전 금액 |
|------|----------|
| 요청 1 | 5,000원 |
| 요청 2 | 3,000원 |

#### 예상 결과 (정상 동작 시)

- 최종 잔액: 18,000원 (10,000 + 5,000 + 3,000)
- 모든 충전 요청 성공 (HTTP 200)

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (5,000원 충전)     | 요청2 (3,000원 충전)
-----|--------------------------|---------------------------
T1   | SELECT balance (10,000)  |
T2   |                          | SELECT balance (10,000)
T3   | 계산: 10,000 + 5,000     |
T4   |                          | 계산: 10,000 + 3,000
T5   | UPDATE balance = 15,000  |
T6   |                          | UPDATE balance = 13,000  ← 덮어씀!
```

- 최종 잔액: 13,000원 또는 15,000원 (둘 중 하나의 충전 손실)
- **Lost Update 발생**

#### 검증 포인트

1. 두 요청 모두 HTTP 200 응답
2. 최종 잔액이 18,000원이 아니면 동시성 이슈 존재

---

### TC-BAL-002: 동시 잔액 차감 시 잔액 부족 검증 우회

#### 시나리오

잔액이 10,000원인 사용자가 동시에 7,000원씩 2번 차감 요청을 보내면, 하나만 성공해야 합니다.

#### 사전 조건

- 회원 ID: 3002
- 초기 잔액: 10,000원

#### 테스트 데이터

| 요청 | 차감 금액 |
|------|----------|
| 요청 1 | 7,000원 |
| 요청 2 | 7,000원 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (잔액 부족)
- 최종 잔액: 3,000원

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 요청1 (7,000원 차감)     | 요청2 (7,000원 차감)
-----|--------------------------|---------------------------
T1   | SELECT balance (10,000)  |
T2   |                          | SELECT balance (10,000)
T3   | 검증: 10,000 >= 7,000 ✓  |
T4   |                          | 검증: 10,000 >= 7,000 ✓
T5   | UPDATE balance = 3,000   |
T6   |                          | UPDATE balance = 3,000  ← 음수 방지 실패!
```

- 두 요청 모두 성공
- 최종 잔액: 3,000원 (정상) 또는 -4,000원 (음수, 심각한 버그)
- **Race Condition 발생**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "잔고의 금액이 부족합니다")
3. 최종 잔액이 3,000원

---

## 재고 동시성 테스트

### TC-STK-001: 동시 재고 차감 시 Overselling 검증

#### 시나리오

재고가 1개인 상품을 2명의 사용자가 동시에 주문하면, 1명만 성공해야 합니다.

#### 사전 조건

- 상품 ID: 5001
- 초기 재고: 1개
- 사용자 A ID: 4001, 잔액: 100,000원
- 사용자 B ID: 4002, 잔액: 100,000원

#### 테스트 데이터

| 요청 | 사용자 | 주문 수량 | 상품 가격 |
|------|--------|----------|----------|
| 요청 1 | 4001 | 1개 | 10,000원 |
| 요청 2 | 4002 | 1개 | 10,000원 |

#### 예상 결과 (정상 동작 시)

- 1개 요청 성공, 1개 요청 실패 (재고 부족)
- 최종 재고: 0개

#### 예상 결과 (동시성 이슈 발생 시)

```
시간 | 사용자 A 주문            | 사용자 B 주문
-----|--------------------------|---------------------------
T1   | Lock(회원 A) 획득        | Lock(회원 B) 획득  ← 다른 row!
T2   | SELECT stock (1개)       | SELECT stock (1개)
T3   | 검증: 1 >= 1 ✓           | 검증: 1 >= 1 ✓
T4   | UPDATE stock = 0         |
T5   |                          | UPDATE stock = -1  ← Overselling!
```

- 두 요청 모두 성공
- 최종 재고: 0개 또는 -1개
- **Overselling 발생**

#### 검증 포인트

1. 정확히 1개 요청만 성공 (HTTP 200)
2. 1개 요청은 실패 (HTTP 409, "재고가 부족합니다")
3. 최종 재고가 0개
4. 주문은 1건만 생성

---

### TC-STK-002: 동시 대량 주문 시 재고 초과 검증

#### 시나리오

재고가 5개인 상품을 5명의 사용자가 동시에 2개씩 주문하면, 최대 2명만 성공해야 합니다.

#### 사전 조건

- 상품 ID: 5002
- 초기 재고: 5개
- 사용자 ID: 4003 ~ 4007, 각각 잔액 100,000원

#### 테스트 데이터

| 요청 | 사용자 | 주문 수량 |
|------|--------|----------|
| 요청 1 | 4003 | 2개 |
| 요청 2 | 4004 | 2개 |
| 요청 3 | 4005 | 2개 |
| 요청 4 | 4006 | 2개 |
| 요청 5 | 4007 | 2개 |

#### 예상 결과 (정상 동작 시)

- 최대 2개 요청 성공 (4개 = 2 × 2), 나머지 실패
- 최종 재고: 1개 (5 - 4 = 1) 또는 0개 이상

#### 예상 결과 (동시성 이슈 발생 시)

- 3개 이상 요청 성공
- 최종 재고: 음수 (-1, -3, -5 등)
- **심각한 Overselling 발생**

#### 검증 포인트

1. 성공한 주문 수 × 주문 수량 ≤ 초기 재고 (5개)
2. 최종 재고 ≥ 0
3. 총 판매 수량이 초기 재고를 초과하지 않음

---

## 테스트 실행 방법

### 테스트 파일 위치

```
src/test/kotlin/kr/hhplus/be/server/
├── application/
│   └── concurrency/
│       ├── BalanceConcurrencyIntegrationTest.kt
│       └── StockConcurrencyIntegrationTest.kt
└── resources/sql/
    ├── balance-concurrency-setup.sql
    ├── balance-concurrency-cleanup.sql
    ├── stock-concurrency-setup.sql
    └── stock-concurrency-cleanup.sql
```

### 실행 명령어

```bash
# 전체 동시성 테스트 실행
./gradlew test --tests "*ConcurrencyIntegrationTest"

# 잔액 동시성 테스트만 실행
./gradlew test --tests "BalanceConcurrencyIntegrationTest"

# 재고 동시성 테스트만 실행
./gradlew test --tests "StockConcurrencyIntegrationTest"
```

### 테스트 결과 해석

#### 동시성 이슈가 있는 경우 (현재 상태)

```
✗ TC-BAL-001: 최종 잔액이 18,000원이 아님 (Lost Update)
✗ TC-BAL-002: 두 요청 모두 성공 (Race Condition)
✗ TC-STK-001: 두 요청 모두 성공 (Overselling)
✗ TC-STK-002: 3개 이상 요청 성공 (Overselling)
```

#### 동시성 이슈 해결 후

```
✓ TC-BAL-001: 최종 잔액 18,000원
✓ TC-BAL-002: 1개 성공, 1개 실패 (잔액 부족)
✓ TC-STK-001: 1개 성공, 1개 실패 (재고 부족)
✓ TC-STK-002: 최대 2개 성공, 재고 ≥ 0
```

---

## 테스트 코드 구조

### 공통 패턴

```kotlin
@IntegrationTest
@AutoConfigureMockMvc
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@SqlGroup(
    Sql(scripts = ["/sql/{test}-setup.sql"], executionPhase = BEFORE_TEST_METHOD),
    Sql(scripts = ["/sql/{test}-cleanup.sql"], executionPhase = AFTER_TEST_METHOD),
)
class {Feature}ConcurrencyIntegrationTest {

    @Test
    fun `동시 요청 시 동시성 이슈 검증`() {
        runBlocking {
            val startSignal = CompletableDeferred<Unit>()

            val jobs = requests.map { request ->
                async(Dispatchers.IO) {
                    startSignal.await()  // 모든 코루틴이 준비될 때까지 대기
                    // 요청 실행
                }
            }

            startSignal.complete(Unit)  // 동시 시작
            val responses = jobs.awaitAll()

            // 검증
        }
    }
}
```

---

## 참고 자료

- [동시성 이슈 분석](동시성-이슈-분석.md)
- [아키텍처 및 구조](아키텍처-및-구조.md)
- 기존 동시성 테스트:
  - `CouponIssuanceConcurrencyIntegrationTest.kt`
  - `PlaceOrderConcurrencyIntegrationTest.kt`
