# 데이터베이스 정규화 검토 보고서
데이터베이스 스키마에 대한 정규화 검토 결과를 요약합니다.

## 검토 요약
- 대부분의 테이블은 1차 정규형(1NF)과 2차 정규형(2NF)을 충족하지만, 몇몇 테이블에서 3차 정규형(3NF) 또는 고차 정규형을 위반할 수 있는 중복·다중 의미 컬럼이 발견되었습니다.
- `payment_summary`는 `order_summary_id`가 결정하는 `member_id`를 중복 보관하고 있어 갱신 이상 가능성이 있습니다.
- `coupon_history`는 서로 다른 이벤트 유형을 한 테이블에 혼재시키며, `coupon_id`가 존재할 때 다시 `coupon_summary_id`, `member_id`를 보관하여 전이적 종속과 다치 종속 위험이 있습니다.
- `member_balance`는 사실상 `member`와 1:1 관계로, 별도의 식별자를 두고 `member_id`에 UNIQUE 제약을 추가한 설계는 3NF 자체를 위반하지는 않지만, PK 중복으로 인해 관리 복잡도가 커집니다.
- `coupon_issuance`의 `issued_count` 등 집계 컬럼은 정규형을 의도적으로 희생한 부분으로, 동시성/갱신 이상을 제어할 수단이 필요합니다.

## 분석

### 1. payment_summary (3NF 위반 가능)
- 관찰: `init/schema.sql`에 따르면 `payment_summary`는 `order_summary_id`와 `member_id`를 모두 NOT NULL로 저장합니다. 그러나 `order_summary`(`order_summary.member_id`)가 이미 주문-회원 관계를 보장하므로, 함수 종속 `order_summary_id → member_id`가 성립합니다.
- 영향: 기본 키 `id`를 통해 `order_summary_id`를, 그리고 `order_summary_id`를 통해 다시 `member_id`를 결정하는 전이적 종속이 발생하여 3NF를 위반합니다. 데이터 정합성 트리거가 없으면 주문의 소유자가 변경될 때 결제 레코드를 모두 수정해야 하는 갱신 이상이 발생합니다.
- 권고: `payment_summary.member_id`를 제거하고 조회 시 `order_summary` 조인을 통해 회원 정보를 취득하거나, 불가피하게 유지해야 한다면 CHECK 제약/트리거/애플리케이션 레벨 검증으로 두 필드의 정합성을 강제하십시오.

### 2. coupon_history (분석 편의를 위한 의도적 비정규화)
- 관찰: `coupon_history`는 조회·분석 시 추가 조인 없이도 쿠폰·회원 속성을 바로 활용하려는 목적으로 `coupon_id`, `coupon_summary_id`, `member_id` 등을 중복 저장합니다. 또한 이벤트 유형별로 필요한 속성이 달라 `order_summary_id`처럼 일부 컬럼은 특정 이벤트에서만 값이 채워집니다.
- 영향: 의도한 반정규화이므로 3NF 위반 자체가 허용되지만, 원본 테이블(예: `coupon`, `member`)에서 속성이 변경될 때 이를 즉시 동기화하지 않으면 이력 데이터가 실제와 어긋나는 위험이 있습니다. 다중 이벤트 유형을 한 테이블에 담고 있으므로 NULL 값과 조건부 의존성 관리가 복잡해질 수 있습니다.
- 권고:
  1. 중복 컬럼의 신뢰도를 유지하기 위해 트리거, 이벤트 기반 동기화, ETL 검증 배치 등 관리 절차를 정의하십시오.
  2. 업데이트가 잦은 속성은 스냅샷 전략(변경 시 새 이력 행 생성) 또는 별도 Dimension 테이블과의 조합 등 데이터 품질 정책을 문서화하는 것이 좋습니다.
  3. 이벤트 타입별 선택적 속성을 스키마 차원에서 명확히 하기 위해 CHECK 제약, 부분 인덱스, 뷰로 유효성 검증을 보완하거나, 필요 시 서브테이블(예: `coupon_history_order`)로 분리해도 됩니다.

### 3. member_balance (향후 1:N 확장 고려)
- 관찰: 현재 스키마는 `id`를 PK로, `member_id`에 UNIQUE 제약을 두어 회원당 하나의 잔액만 존재한다고 가정합니다. 그러나 향후 1:N 구조(예: 잔액 구분, 멀티 지갑)가 필요하다면 이 UNIQUE 제약이 장애물이 됩니다.
- 영향: 1:1을 전제로 한 UNIQUE 제약은 1:N 시나리오에서 정규형 위반보다는 기능 제약이 문제이며, 레코드가 여러 개 생기는 순간 제약 위반으로 삽입 자체가 불가합니다. 또한 다중 잔액을 저장할 경우 구분자 컬럼이 없다면 의미상 중복이 발생합니다.
- 권고: 1) 1:N 확장 가능성을 반영해 `member_id`의 UNIQUE 제약을 제거하고, 잔액 유형을 명시하는 컬럼(예: `wallet_type`, `balance_type`) 또는 유효 기간/버전 관리 컬럼을 추가해 후보 키를 정의하십시오. 2) 기록성 테이블이라면 누적 잔액 대신 입출금 트랜잭션 테이블로 분리하고, 현재 잔액은 뷰·캐시로 계산하는 구조도 검토할 수 있습니다. 3) 1:1 구조를 당분간 유지해야 한다면, UNIQUE 제약을 유지하되 향후 마이그레이션 절차(제약 제거, 신규 키 도입)를 문서화해 두는 것이 좋습니다.

### 4. coupon_issuance.issued_count 등 집계 컬럼 (의도적 비정규화)
- 관찰: 발급 수(`issued_count`)는 `coupon` 또는 `coupon_history`로부터 계산 가능한 파생 값입니다.
- 영향: 다중 트랜잭션 환경에서 실시간 동기화가 실패하면 불일치가 발생하는 갱신 이상(Anomaly) 위험이 있습니다.
- 권고: 집계 컬럼을 유지하려면 트랜잭션 수준에서 증감 규칙을 명확히 하거나, 뷰/물리화된 뷰/배치 집계로 대체하여 정규형을 유지하십시오.

## 조치 및 개선
- `payment_summary.member_id` 제거  
  - `init/schema.sql` 및 관련 JPA 엔티티/매퍼에서 `member_id` 컬럼을 삭제했습니다.  
  - `payment_summary`는 이제 `order_summary_id`만을 통해 회원 정보를 추적하며, 3NF 위반 가능성이 해소되었습니다.  
  - 결제 조회 시 회원 정보가 필요하면 `order_summary`와의 조인을 통해 취득하도록 애플리케이션 로직을 반영했습니다.
- 기타 항목은 현재 구조 유지  
  - `coupon_history`: 분석 편의를 위한 의도적 비정규화로, 스냅샷 정책/ETL 등을 통해 품질을 관리합니다.  
  - `member_balance`: 향후 1:N 확장을 고려해 UNIQUE 유지, 마이그레이션 시나리오를 별도로 문서화합니다.  
  - `coupon_issuance.issued_count`: 동시성 제어(락/분산락)로 이상을 관리하며 현 구조를 유지합니다.

## 추가 참고 사항
- 현재 모든 관계가 "논리 FK"로만 표시되어 있으며 물리적 FK 제약이 없습니다. 정규화 자체와는 별개지만, FK 미사용은 정규형을 지켜도 무결성을 보장하지 못하므로 가능한 한 FK를 도입하는 것을 권장합니다.
- 정규화 이후에도 성능 요구로 특정 중복을 허용해야 한다면, 그 이유와 동기화를 위한 보완 장치(트리거, 도메인 이벤트 등)를 문서화해 두는 것이 좋습니다.
