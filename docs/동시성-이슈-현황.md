# 동시성 이슈 현황

> 작성일: 2025-12-22
> 목적: 동시성 이슈 보완 전 현재 시스템의 동시성 처리 상태 분석

---

## 1. 테스트 실행 결과 요약

| 테스트 ID | 테스트명 | 결과 | 동시성 이슈 |
|-----------|----------|------|-------------|
| TC-BAL-001 | 잔액 충전 API - 동시 충전 시 Lost Update 검증 | ❌ 실패 | **있음** |
| TC-BAL-002 | 주문 API - 동시 주문 시 잔액 차감 Race Condition 검증 | ✅ 통과 | 없음 |
| TC-STK-001 | 재고 1개 상품 동시 주문 테스트 | ❌ 실패 | **있음** |
| TC-STK-002 | 재고 5개 상품 동시 대량 주문 테스트 | ❌ 실패 | **있음** |

---

## 2. 테스트별 상세 분석

### 2.1 TC-BAL-001: 잔액 충전 Lost Update

**검증 대상**: `MemberBalanceService.recharge()` 메서드

#### 시나리오
```
초기 상태: 사용자 A의 잔액 10,000원

[동시 요청]
- 요청 1: 5,000원 충전
- 요청 2: 3,000원 충전

기대 결과: 최종 잔액 18,000원 (10,000 + 5,000 + 3,000)
```

#### 테스트 결과
```
❌ 실패
- 기대값: 18,000원
- 실제값: 13,000원 (또는 15,000원)
- 손실 금액: 5,000원 (또는 3,000원)
```

#### 원인 분석
```
시간 →
Thread 1: READ(10,000) ─────────────────────── WRITE(15,000)
Thread 2: ────── READ(10,000) ── WRITE(13,000)

결과: Thread 1의 충전(5,000원)이 Thread 2에 의해 덮어써짐 (Lost Update)
```

#### 문제 코드 위치
- `MemberBalanceService.recharge()`: Lock 없이 잔액 조회 후 업데이트

---

### 2.2 TC-BAL-002: 주문 시 잔액 차감 (동일 사용자)

**검증 대상**: `PlaceOrderFacade.placeOrder()` 내 잔액 차감 로직

#### 시나리오
```
초기 상태: 사용자 A의 잔액 15,000원, 상품 가격 10,000원

[동시 요청 - 동일 사용자]
- 요청 1: 10,000원 상품 주문 (idempotency-key-1)
- 요청 2: 10,000원 상품 주문 (idempotency-key-2)

기대 결과: 1건 성공, 1건 실패 (잔액 부족)
```

#### 테스트 결과
```
✅ 통과
- 성공: 1건
- 실패: 1건 (ConflictResourceException: 잔고의 금액이 부족합니다)
- 최종 잔액: 5,000원
```

#### 통과 이유: Member Lock에 의한 보호
```kotlin
// PlaceOrderFacade.kt
@Transactional
fun placeOrder(...) {
    // Member 조회 시 Pessimistic Lock 획득
    val member = memberQueryService.getMemberWithLock(memberId)  // FOR UPDATE

    // 이후 로직은 Lock 보호 하에 순차 실행
    balanceService.reduce(...)
    stockService.reduce(...)
}
```

```
시간 →
Thread 1: LOCK(member) ── 잔액확인(15,000) ── 차감 ── COMMIT ── UNLOCK
Thread 2: ──────────────── WAIT ──────────────────────────────── LOCK ── 잔액확인(5,000) ── 실패

결과: 동일 사용자 요청이 직렬화되어 Race Condition 방지
```

---

### 2.3 TC-STK-001: 재고 1개 상품 Overselling

**검증 대상**: `ProductSummaryService.reduceStock()` 메서드

#### 시나리오
```
초기 상태: 상품 재고 1개

[동시 요청 - 다른 사용자]
- 사용자 A: 1개 주문
- 사용자 B: 1개 주문

기대 결과: 1명 성공, 1명 실패 (재고 부족)
```

#### 테스트 결과
```
❌ 실패
- 기대: 1명 성공, 1명 실패
- 실제: 2명 모두 성공
- 생성된 주문: 2건
- Overselling 발생
```

#### 원인 분석
```
시간 →
Thread 1 (User A): LOCK(member_A) ── 재고확인(1) ── 차감 ── COMMIT
Thread 2 (User B): LOCK(member_B) ── 재고확인(1) ── 차감 ── COMMIT

결과: Member Lock은 사용자별로 분리되어 있어,
      다른 사용자 간의 동시 재고 접근을 보호하지 못함
```

#### 문제점
- **Member Lock의 한계**: 동일 사용자 요청만 직렬화, 다른 사용자 간 보호 안됨
- **Product/Stock Lock 부재**: 재고 조회/차감 시 Lock 없음

---

### 2.4 TC-STK-002: 재고 5개 상품 대량 Overselling

#### 시나리오
```
초기 상태: 상품 재고 5개

[동시 요청 - 5명의 다른 사용자]
- 사용자 C: 2개 주문
- 사용자 D: 2개 주문
- 사용자 E: 2개 주문
- 사용자 F: 2개 주문
- 사용자 G: 2개 주문

기대 결과: 최대 2명 성공 (4개 판매), 3명 실패
```

#### 테스트 결과
```
❌ 실패
- 기대: 최대 2명 성공
- 실제: 5명 모두 성공 가능
- 총 판매량: 초기 재고(5개) 초과
- 심각한 Overselling 발생
```

---

## 3. 동시성 보호 현황 매트릭스

| 기능 | 동일 사용자 동시 요청 | 다른 사용자 동시 요청 | 보호 메커니즘 |
|------|----------------------|---------------------|--------------|
| 잔액 충전 | ❌ 보호 안됨 | N/A (단일 사용자 기능) | 없음 |
| 잔액 차감 (주문) | ✅ 보호됨 | N/A (잔액은 사용자별) | Member Lock |
| 재고 차감 (주문) | ✅ 보호됨 | ❌ 보호 안됨 | Member Lock (불완전) |
| 쿠폰 사용 | ✅ 보호됨 | N/A (쿠폰은 사용자별) | Member Lock |

---

## 4. 현재 Lock 구조 분석

### 4.1 Member Lock 적용 범위

```kotlin
// MemberQueryService.kt
@Lock(LockModeType.PESSIMISTIC_WRITE)
fun getMemberWithLock(memberId: Long): Member
```

**보호 범위**:
- ✅ 동일 사용자의 동시 주문 요청
- ✅ 동일 사용자의 동시 잔액 차감
- ✅ 동일 사용자의 동시 쿠폰 사용
- ❌ 다른 사용자 간의 동시 재고 접근
- ❌ 잔액 충전 (주문 플로우가 아님)

### 4.2 Lock이 없는 영역

| 영역 | 문제 | 영향 |
|------|------|------|
| `MemberBalanceService.recharge()` | Lost Update | 충전 금액 유실 |
| `ProductSummaryService.reduceStock()` | Overselling | 재고 초과 판매 |

---

## 5. 비즈니스 영향도

### 5.1 잔액 충전 Lost Update
- **발생 조건**: 같은 사용자가 동시에 여러 번 충전
- **피해**: 고객이 충전한 금액이 유실
- **심각도**: 🔴 높음 (금전적 손실)

### 5.2 재고 Overselling
- **발생 조건**: 다른 사용자들이 동시에 같은 상품 주문
- **피해**: 재고보다 많은 주문 접수, 배송 불가
- **심각도**: 🔴 매우 높음 (고객 불만, 취소 처리 필요)

---

## 6. 권장 개선 사항

### 6.1 잔액 충전 (TC-BAL-001)
```kotlin
// 방법 1: Pessimistic Lock
@Lock(LockModeType.PESSIMISTIC_WRITE)
fun findByIdForUpdate(id: Long): MemberBalance

// 방법 2: Optimistic Lock (@Version)
@Version
var version: Long = 0
```

### 6.2 재고 차감 (TC-STK-001, TC-STK-002)
```kotlin
// 방법 1: Product에 Pessimistic Lock
@Lock(LockModeType.PESSIMISTIC_WRITE)
fun findByIdForUpdate(id: Long): ProductSummary

// 방법 2: Redis 분산 락
fun reduceStockWithLock(productId: Long, quantity: Int) {
    redisLockTemplate.executeWithLock("stock:$productId") {
        // 재고 차감 로직
    }
}

// 방법 3: Database-level 원자적 업데이트
@Modifying
@Query("UPDATE ProductSummary p SET p.stockQuantity = p.stockQuantity - :quantity WHERE p.id = :id AND p.stockQuantity >= :quantity")
fun reduceStock(id: Long, quantity: Int): Int  // 영향받은 행 수 반환
```

---

## 7. 테스트 파일 위치

| 파일 | 경로 |
|------|------|
| 잔액 동시성 테스트 | `src/test/kotlin/.../concurrency/BalanceConcurrencyIntegrationTest.kt` |
| 재고 동시성 테스트 | `src/test/kotlin/.../concurrency/StockConcurrencyIntegrationTest.kt` |
| 잔액 테스트 데이터 | `src/test/resources/sql/balance-concurrency-setup.sql` |
| 재고 테스트 데이터 | `src/test/resources/sql/stock-concurrency-setup.sql` |

---

## 8. 결론

### 현재 상태
- **3건의 동시성 이슈 확인**: TC-BAL-001, TC-STK-001, TC-STK-002
- **1건의 정상 작동 확인**: TC-BAL-002 (Member Lock 보호)

### Member Lock의 한계
현재 시스템의 Member Lock은 **"동일 사용자의 동시 요청"**만 보호합니다. 이는 다음을 의미합니다:

| 보호됨 | 보호 안됨 |
|--------|----------|
| 한 사용자가 동시에 2번 결제 | 두 사용자가 동시에 마지막 1개 재고 주문 |
| 한 사용자가 동시에 2번 쿠폰 사용 | 인기 상품 선착순 구매 |

### 우선순위
1. 🔴 **긴급**: 재고 Overselling 방지 (TC-STK-001, TC-STK-002)
2. 🟠 **높음**: 잔액 충전 Lost Update 방지 (TC-BAL-001)
